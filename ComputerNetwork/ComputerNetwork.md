# Computer Network

## OSI(七层)

**物 数 网 传 会 表 应**

OSI是Open System Interconnect的缩写，意为开放式系统互联

| 层         | 官方解释                                                     | 通俗解释                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 应用层     | 网络进程到应用程序。针对特定应用规定各层协议、时序、表示等，进行封装 。在端系统中用软件来实现，如HTTP等 | 通信类型：电子邮件，文件传输，客户端/服务器                  |
| 表示层     | 数据表示形式，加密和解密，把机器相关的数据转换成独立于机器的数据。规定数据的格式化表示 ，数据格式的转换等 | 数据格式化、代码转换、数据加密：ascill到ebcdic，bcd到binary  |
| 会话层     | 主机间通讯，管理应用程序之间的会话。规定通信时序 ；数据交换的定界、同步，创建检查点等 | 开始，停止会话。维持秩序。                                   |
| 传输层     | 在网络的各个节点之间可靠地分发数据包。所有传输遗留问题；复用；流量；可靠(**Segment**) | 确保传递整个文件或消息，检查所传输的数据是正确的             |
| 网络层     | 在网络的各个节点之间进行地址分配、路由和（不一定可靠的）分发报文。路由（ IP寻址）；拥塞控制。(**Packet**) | 根据网络地址将数据路由到不同的LAN和WAN即选择最合适的路径，检查Ip地址、路由设置 |
| 数据链路层 | 一个可靠的点对点数据直链。检错与纠错（CRC码）；多路访问；寻址(**Frame**) | 错误检测并打包，确保发送的数据未被破坏。                     |
| 物理层     | 一个（不一定可靠的）点对点数据直链。定义机械特性；电气特性；功能特性；规程特性 | 电信号和布线                                                 |

## TCP/IP(四层)

应用层、传输层、网络层、网络接口层

## 五层协议

| 层         | 功能                                                         | 举例                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 应用层     | 为操作系统或网络应用程序提供访问网络服务的接口；通过应用进程间的交互来完成特定网络应用，应用层协议定义的是应用进程间通信和交互规则。不同的网络应用层有不同的应用层协议，应用层交互的数据单元称为报文。当不同的应用进程数据通信或者数据交换时，就去调用应用层的不同协议实体，让这些实体去调用TCP或者UDP层服务来进行网络传输 | 万维网应用的HTTP协议，电子邮件的SMTP协议，支持文件传送的FTP协议 |
| 传输层     | 向两个主机中应用进程之间的通信提供通用的数据传输服务。应用进程以利用该服务传送应用层报文 | 传输控制协议TCP：提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段；用户数据报协议UDP：提供无连接的、尽最大努力的数据传输服务，不保证数据传输的可靠性，单位是用户数据报； |
| 网络层     | 网络层的主要功能是寻址和对数据报的封装以及重要的路由选择功能。 这些功能大部分都是由IP协议来完成的，再加上地址解析协议（Address Resolution Protocol，ARP）、因特网控制报文协议（Internet Control Message Protocol，ICMP）等协议从旁协助，所以IP协议是本层众多实体中的核心。 | 网际协议（Internet Protocol，IP）：该协议是一个无连接的协议，主要负责将数据报从源结点转发到目的结点。也就是说，IP协议通过对每个数据报中都有的源地址和目的地址进行分析，然后进行路由选择（即选择一条到达目标的最佳路径），最后再转发到目的地。需要注意的是：**IP协议只是负责对数据进行转发，并不对数据进行检查**。也就是说，它不负责数据的可靠性，这样设计的主要目的是提高IP协议传送和转发数据的效率；地址解析协议（Address Resolution Protocol，ARP）：该协议主要负责将TCP/IP网络中的IP地址解析和转换成计算机的物理地址，以便于物理设备（如网卡）按该地址来接收数据 ；反向地址解析协议（Reverse Address Resolution Protocol，RARP）：该协议的作用与ARP的作用相反，它主要负责将设备的物理地址解析和转换成IP地址；因特网控制报文协议（Internet Control Message Protocol，ICMP）：该协议主要负责发送和传递包含控制信息的数据报，这些控制信息包括哪台计算机出了什么错误、网络路由出现了什么错误等内容； |
| 数据链路层 | 两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议，数据链路层将网络层交下来IP数据报组装成数据帧，在两个相邻节点间的链路上传送帧 | 数据帧：所谓数据帧（Data frame），就是数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。其中，帧头和帧尾包含一些必要的控制信息，比如同步信息、地址信息、差错控制信息等；数据部分则包含网络层传下来的数据，比如IP数据包 |
| 物理层     | 物理层上所传数据的单位是比特，确定要连接电缆的插头应当有多少根引脚，以及各条引脚应如何连接。 | 传递信息所利用的是一些物理媒体，如电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。 |

## TCP和UDP的区别

![image-20190318171504150](https://ws3.sinaimg.cn/large/006tKfTcgy1g172emnrwlj30ws0u07wh.jpg)

1. TCP协议是一种**可靠**的、**面向连接**的协议:保证通信主机之间有可靠的字节流传输，完成流量控制功能，协调收发双方的发送与接收速度，达到正确传输的目的
2. UDP是一种**不可靠**、**无连接**的协议:其特点是协议简单、额外开销小、效率较高，但是不能保证传输是否正确，UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。

**面向连接**举例：两个人之间通过电话进行通信;
**面向无连接**举例：邮政服务，用户把信函放在邮件中期待邮政处理流程来传递邮政包裹。
显然，不可达代表不可靠。

### 什么时候应该使用TCP

当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 
在日常生活中，常见使用TCP协议的应用如下：

```
浏览器，用的HTTP
FlashFXP，用的FTP
Outlook，用的POP、SMTP
Putty，用的Telnet、SSH
QQ文件传输
```

### 什么时候应该使用UDP

当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 
比如，日常生活中，常见使用UDP协议的应用如下：

```
QQ语音
QQ视频
TFTP
```


## TCP对应的协议和UDP对应的协议

### TCP

HTTP协议：从Web服务器传输超文本到本地浏览器的传送协议，默认使用80端口。

FTP：文件传输协议，默认使用21端口。

SMTP：简单邮件传送协议，用于发送邮件，默认使用25号端口。

POP3：和SMTP对应，POP3用于接收邮件，默认使用110端口

Telnet：一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务，默认使用23端口

### UDP

DNS：域名解析服务，将域名地址转换为IP地址，默认使用53号端口。

TFTP(Trival File Transfer Protocal)：简单文件传输协议，默认使用69号端口。

SNMP：简单网络管理协议，默认使用161号端口，是用来管理网络设备的。

## TCP的报文段

TCP是一种面向连接的、可靠的传输层协议，通过TCP报文段进行传输，报文段分为头部和数据两个部分，头部包含了此报文段的一些基本信息，基本格式如下图：

![屏幕快照 2019-03-06 13.26.06](https://ws2.sinaimg.cn/large/006tKfTcgy1g0t1b4vlj3j30nu0kw769.jpg)

- 源端口和目的端口：即应用程序在客户端和服务器端所对应的端口号

- 序号（seq）和确认序号（ack）：是TCP可靠传输的关键部分。

  - 序号：是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。
  - 确认号：即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当**ACK标志**为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。

- 数据偏移／首部长度：表明报文段**头部的长度**。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。

- 保留：为将来定义新的用途保留，现在一般置0。

- 控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能，0无效，1有效 

  - URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。

  - ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。

  - PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。

  - RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求

  - SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。

  - FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。

- 窗口：滑动窗口大小，用来**告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制**。窗口大小是一个**16bit**字段，因而窗口大小最大为65535（$2^{16}-1$）。

- 校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证

- 紧急指针：指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。

## TCP三次握手

![image-20190306141223243](https://ws4.sinaimg.cn/large/006tKfTcgy1g0t1oscbxyj30w80i6q5q.jpg)

三次握手:TCP是通过报文段进行通信的，在建立TCP连接过程中，需要客户端和服务端总共发送3个报文段以确认连接的建立。

第一次握手：Client将标志位SYN置为1，随机产生一个序号（seq）J，并将该数据包发送给Server，Client进入**SYN_SENT**状态，等待Server确认。

第二次握手：Server接收到报文段，生成一个新的报文段发送给Client，新报文段中：SYN = 1，ACK = 1，序号（seq）= J+1，确认序号（ack） = k（k为随机生成）；Server进入**SYN_RCVD**状态

第三次握手：Client收到报文段，对报文段进行校验（ACK是否为1，ack是否为J+1），校验通过生成一个新的报文段发送给Server：ACK = 1，ack = K+1，此时Client进入**ESTABLISHED**状态；Server对接收到的报文段校验，校验通过进入**ESTABLISHED**状态。

### 为什么是三次握手而不是两次

第一次连接请求报文由于网络节点长时间滞留了，导致延误到连接释放后的某个时间才到达 Server。这时 Server 会再次给 Client 发送确认报文(第二次握手)，但是 Client 进程程序并不会理睬确认报文，因为 Client 没有发送连接请求。

现在假如没有第三次握手就会建立连接，那么这次滞后的连接请求报文就会导致 TCP 误建立连接，而 Client 却不知已经建立连接，并不会发送数据给 Server，这样 Server 就会一直处于等待状态，这样就白白浪费了 Server 的很多资源。但有了第三次握手就会避免这种问题的发生，虽然延迟的连接请求发送到了 Server，但 Client 不会处理 Server 的确认报文，也不会再次发送确认请求报文，这样 Server 就知道了 Client 并没有真正想建立连接。

## TCP四次挥手

![image-20190318175354974](https://ws3.sinaimg.cn/large/006tKfTcgy1g173izpokxj30u00zrdm1.jpg)

由于TCP连接时**全双工**的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭：

第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态

第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

第四次挥手:Client收到FIN后， Client 进入 TIME-WAIT状态，此时连接还没释放，必须经过时间等待计时器设置的时间 `2MSL` 后，Client 才进入 CLOSED 状态。时间 MSL 叫做`最长报文段寿命`，RFC 793建议设为 2 分钟。也就是说 Client 需要等待2\*MSL=2\*2=4分钟后才可以真正关闭连接然后再去建立下一个连接，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

### 为什么 Client 需要等待 2MSL？

先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。

再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。

### 为什么连接时时三次，断开时是四次

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示**对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了**，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

## TCP流量控制：滑动窗口

所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收，每次Client返回的ACK都会告知Server当前Client窗口的大小，Server会根据窗口的大小来控制发送数据和向前滑动。

## 在浏览器中输入www.baidu.com 后执行的全部过程

- 客户端浏览器请求DNS服务器解析域名www.baidu.com 对应的IP地址，然后通过这个IP地址和默认端口80，和服务器建立TCP连接，连接建立之后通过TCP将HTTP会话封装成数据包。

- 在客户端的**传输层**，把HTTP会话请求分成报文段，添加源和目的端口（如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口）然后使用IP层的IP地址查找目的端。

- 在客户端的**网络层**，通过**查找路由表**确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，主要是通过查找路由表来决定通过哪个路径到达服务器。

- 在客户端的**链路层**，数据包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用`ARP`（地址解析协议：**将ip地址解析成物理地址**）的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

## HTTP协议包括哪些请求？

`HTTP（HyperTextTransferProtocol）`是超文本传输协议的缩写

常用的请求有：get，post，update，delete，head，options。

- GET：请求读取由URL所标志的数据 
- POST：给服务器添加或者更新数据 
- PUT：在给定的URL下存储一个文档 
- DELETE：删除给定的URL所标志的资源 
- OPTIONS：服务器针对特定资源所支持的HTTP请求方法 
- HEAD：向服务器索要与GET请求相一致的响应，只不过`响应体`将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在*响应消息头中的元信息*

## HTTP中POST与GET的区别

GET一般用于获取/查询资源信息，而POST一般用于更新资源信息

- 根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。
   (1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
   注意：这里安全的含义仅仅是指是非修改信息。
   (2).幂等的意味着对同一URL的多个请求应该返回同样的结果。
- 根据HTTP规范，POST表示可能修改变服务器上的资源的请求。
- get提交数据会有大小的限制（1024k），post提交无限制

##  HTTP协议的格式

#### HTTP请求

![2](https://ws2.sinaimg.cn/large/006tKfTcgy1g175a6yz27j309q03a0su.jpg)

- 第一部分即为请求行，分别包括 `请求方法` 、 `请求URI` 、 `HTTP版本` ，它们之间使用英文空格 `SP` 分隔，此外，最后是一个换行符 `CRLF` 。
- 第二部分是以 `key: value` 形式组成的请求头。其中包括 请求头-request-header （如 `Host``User-AgentAccept`）和 实体头-entity-header （如 `Content-Type``Content-Length`）。每一对 `key: value` 请求头后也都有一个 `CRLF` 。
- 第三部分是固定不变的单独一行 `CRLF（回车换行）` ，用于分隔第二部分和第四部分。
- 第四部分是发送请求时带上的请求实体，即 `{"name":"caijialinxx"}` 。命令行在第二部分中添加的 `Content-Type: application/json` 请求头，标示着第四部分是 JSON 格式的数据，只在POST请求中存在，因为GET请求并不包含任何实体

#### HTTP响应

![3](https://ws4.sinaimg.cn/large/006tKfTcgy1g175bsuog0j30ap03m0sw.jpg)

- 第一部分即为状态行，分别包括 `HTTP版本` 、 `状态码` 、 `状态解释` ，它们之间使用英文空格 `SP` 分隔，此外，最后是一个换行符 `CRLF` 。在此报文中我们可以看到状态码是 `302` ，表示页面暂时被另一个 URI 所替代，但客户端在未来的请求中仍应使用当前请求的 URI 。
- 第二部分是以 `key: value` 形式组成的响应头。其中包括 普通头-general-header (`Connection` , `Date`) 、 响应头-response-header (`ETag` , `Server`) 和 实体头-entity-header (`Content-Type` , `Content-Length`) 。每一对 `key: value` 请求头后也都有一个 `CRLF` 。
- 第三部分是固定不变的单独一行 `CRLF` ，同请求报文的第三部分。
- 第四部分是响应实体。在此报文第二部分中我们可以看到 `Content-Type: text/html` 响应头，表明第四部分是一个 HTML 文档，它有 3824 字节长度的数据。

###  常见请求和响应头

请求头：Accept/Accept—Language/Cache-Control/Cookie/User-Agent/Date/Host/Range

返回头：Accept-Ranges/Date/Cache-Control/Content-Length

## Http缓存

![F5D7A0F2-8A65-45F7-A716-3AB1A4E91F82](https://ws1.sinaimg.cn/large/006tKfTcgy1g0t2eol1vpj30gu0dbacl.jpg)

1. **请求处理** 用户发起一个http请求，缓存获取到URL，根据URL查找是否有匹配的副本，这个副本可能在内存中，也可能在本地磁盘。
2. **新鲜度检测** 如果缓存中存在所请求资源的副本，则进行新鲜度检测。新鲜度检测举个简单的例子，我们在商店买了一瓶汽水，汽水瓶上肯定会标有过期时间，我们会根据这个过期时间和现在的时间做对比，看看饮料过期了没，如果没过期，我们正常喝就行了，如果已经过期，我们肯定要找商家。其实这就是一个新鲜度检测的过程，HTTP请求的新鲜度检测流程也是这样的，HTTP发起一个请求时，发现缓存中有相应的副本，接着就会检查这个副本有没有过期，如果没有过期，直接使用。如果已经过期，则进行再验证。
3. **服务器再验证** 缓存中的文档过期了并不代表它和服务器上的不一样，所以这个时候就需要问问服务器，过期的这段时间里这个文档到底有没有改变。如果改变了，缓存就会获取一份新的文档副本，然后发送给客户端。如果没有改变，缓存只需要获取新的首部，包括一个新的过期时间，并对缓存中的首部更新。
4. **创建响应并返回** 我们希望缓存看起来就像是来自原始服务器一样，缓存将已缓存的服务器响应首部作为响应首部，发送给客户端。

扩展（缓存保质期的实现）：HTTP中，通过`Cache-Control`首部和`Expires`首部为文档指定了过期时间，通过对过期时间的判断，缓存就可以知道文档是不是在保质期内。Expires首部和Cache-Control:max-age 首部都是来告诉缓存文档有没有过期，为什么需要两个响应首部来做这件简单的事情了？其实这一切都是历史原因，Expires首部是HTTP 1.0中提出来的，因为他使用的是**绝对日期**，如果服务端和客户端时钟不同步的话（实际上这种情况非常常见），缓存可能就会认为文档已经过了保质期。 HTTP 1.1为了修正这个问题，引入了Cache-Control:max-age 首部，这个首部使用**相对时间**来控制保质期。

##  Http和Socket区别

Socket 可以理解为对 TCP、UDP 协议在程序使用层面的封装，提供出一些 api 来供程序员调用开发，这就是 Socket 最表层的含义。

> 1. Http是一个协议，Socket是一个接口
> 2. Http可能是基于Socket的
> 3. Socket可以维持一个长连接，http是请求响应式，通常Socket效率高

###  Http1.0 /1.1/2.0区别

> 1. 1.1相对于1.0：
>    1. 支持长连接
>
>    2. 增加了host域
>
>    3. 增加了Range(客户端) & Content-Range（服务端）头域，支持断点续传
>
>       Range: bytes=500-999 表示需要第 500-999 字节范围的内容 
>
>       Content-Range: bytes 0-499/22400，表示当前发送的数据的范围为0－499 ，而 22400 则是文件的总大小。
>
>       返回头的区别：
>
>       HTTP/1.1 200 Ok（不使用断点续传方式） 
>       HTTP/1.1 206 Partial Content（使用断点续传方式）
> 2. 2.0 相对于1.x：
>
>    1. 支持多路复用
>    2. 采用二进制分帧
>    3. 首部压缩
>    4. 服务器推送

##  HTTPs

 HTTPS (基于安全套接字层的超文本传输协议 或者是 HTTP over SSL) 是一个 Netscape 开发的 Web 协议。
 你也可以说：HTTPS = HTTP + SSL
 HTTPS 在 HTTP 应用层的基础上使用安全套接字层作为子层。

### SSL建立过程

> 1. 客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法
> 2. 服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）
> 3. 客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器
> 4. 服务器使用自己的私钥，获取客户端丝发来的随机数（即Premaster secret）
> 5. 客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程

### 为什么需要 HTTPS ？

 超文本传输协议 (HTTP) 是一个用来通过互联网传输和接收信息的协议。HTTP
 使用请求/响应的过程，因此信息可在服务器间快速、轻松而且精确的进行传输。当你访问 Web 页面的时候你就是在使用 HTTP 协议，但 HTTP是不安全的，可以轻松对窃听你跟 Web服务器之间的数据传输。在很多情况下，客户和服务器之间传输的是敏感歇息，需要**防止未经授权的访问**。为了满足这个要求，网景公司(Netscape)推出了[HTTPS](https://link.jianshu.com?t=http://www.nowamagic.net/librarys/veda/tag/https)，也就是基于安全套接字层的 HTTP 协议。

### HTTP 和 HTTPS 的相同点

 大多数情况下，HTTP 和 HTTPS 是相同的，因为都是采用同一个基础的协议，作为 HTTP 或 HTTPS 客户端——浏览器，设立一个连接到
 Web
 服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。系统使用统一资源定位器
 URI 模式，因此资源可以被唯一指定。而 HTTPS 和 HTTP 唯一不同的只是一个协议头(https)的说明，其他都是一样的。

### HTTP 和 HTTPS 的不同之处

- 1.HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头
- 2.HTTP 是不安全的，而 HTTPS 是安全的
- 3.HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443
- 4.**在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层**
- 5.HTTP 无需加密，而 HTTPS 对传输的数据进行加密
- 6.HTTP 无需证书，而 HTTPS 需要认证证书

##  Http 状态码

1 ：继续，指示信息--表示请求已接收，继续处理

2 ：成功，表示请求已被成功接收、理解、接受

3 ：重定向，要完成请求必须进行更进一步的操作

4 ：请求错误，客户端错误--请求有语法错误或请求无法实现

5： 服务器内部错误，服务器端错误--服务器未能实现合法的请求

**200：**请求被正常处理
**204：**请求被受理但没有资源可以返回
**206：**客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
**301：**永久性重定向
**302：**临时重定向
**303：**与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
**304：**发送附带条件的请求时，条件不满足时返回，与重定向无关
**307：**临时重定向，与302类似，只是强制要求使用POST方法
**400：**请求报文语法有误，服务器无法识别
**401：**请求需要认证
**403：**请求的对应资源禁止被访问
**404：**服务器无法找到对应资源
**500：**服务器内部错误
**503：**服务器正忙

## android网络编程需要注意的几点

端口号应该大于等于1024，因为0~1023内都被系统内部占用了。
在清单文件中添加权限\<uses-permission android:name="android.permission.INTERNET" />

在Android中，TCP和UDP都是网络连接，属于耗时操作，so必须放在子线程中。

## COOKIE和SESSION

### Cookie

Cookie技术是客户端的解决方案：服务器在用户登陆后会按照一定规律生成的标志位，将这个标志发送给客户端，客户端存储此标志，以后请求带上此标志告诉服务器自己的身份，对于这个的理解更直观的例子就是身份证，如果把国家比喻服务器，自己必做客户端，每个人在登记户口后都可以办理身份证，身份证是由国家颁发自己保存也就是Cookie，以后无论你在何时何地只要你拿出身份证就代表你身份，当你去办理车票等信息时只需出事身份证就可证明自己；
cookie的内容主要包括：名字，值，过期时间，路径和域
客户端提交个人信息后，服务端返回数据的同时会在Response Header中返回Cookie信息，客户端保存在固定的位置（Set-Cookie： 设置返回的Cookie）
客户端在下次请求的时候会在Request Header中携带Cookie信息，服务端根据Cookie确认用户身份（如：自动登陆）（Cookie： 设置上传携带的Cookie）

cookie的设置以及发送过程分为以下四步：

![2](https://ws4.sinaimg.cn/large/006tKfTcgy1g0t2vloq1cj30b405kdfu.jpg)

1. 客户端发送一个http请求到服务器端
2. 服务器端发送一个http响应到客户端，其中包含Set-Cookie头部
3. 客户端发送一个http请求到服务器端，其中包含Cookie头部
4. 服务器端发送一个http响应到客户端

- Cookie有效期：由maxAge决定，在服务器返回cookie时已设置号对应的时间
  - 正数：表示有效期 时间为 maxAge，需；序列化在磁盘中，超过时间失效
  - 负数：临时Cookie 不序列化，保存在内存中，关闭浏览器失效
  - 0 ：表示删除该Cookie

- Cookie的修改、删除
  - 修改：创建同名的Cookie在Response中返回，覆盖原来的
  - 删除：创建同名的Cookie，设置maxAge = 0，在Response中返回

### Session

Session技术是服务端的解决方案，通过服务器来保持状态；当客户端第一次请求时服务器首先检查这个客户端的请求里是否已包含了一个session标识，称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，发送给客户端，客户端储存，客户端再次发送请求的时候，会将这个Session id带上，服务器根据SessionID查找用户身份

- Session原理：服务端端每一个session维护一份会话信息数据，客户端和服务端依靠一个全局唯一标sesssion_id来访问会话信息数据
- Session创建：server端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建
- session的保存：
  - Cookie：一般采用Cookie保存sessionId，这样下次请求时会自定添加到Request Header，cookie的名字都是类似于SEEESIONID，比如weblogic对于web应用程序生成的cookie，JSESSIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764，它的名字就是JSESSIONID
  - URL重写（cookie被禁止）：在客户端禁止Cookie时，Cookie就无法保存SessionId和发送了，此时可以使用其他方法解决：把sessionId直接附加在URL的路径之后：http://...../xxx;jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764； 作为字符串附加在请求中：http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764
    与Cookie对比

1. cookie：信息保存在本地容易被第三方或其他获取，发起恶意请求
2. session：信息保存在服务端的内存中，本地只使用cookie保存sessionId

- sessionId的时效
  服务器会设置时间限定，当超过限定时间后还收不到客户端的请求即认为失效，session会结束生命周期，此时需要重新登陆
  没有储存在数据库的Session，会在服务器重启后失效
  用户退出登陆的时候会发起删除session，此时服务器会删除session
- 防止session混乱
  通过设置客户端的令牌来解决；在服务器每次生成一个不同的id返回给客户端，同时保存在session里，客户端提交表单时必须把这个id也返回服务器，程序首先比较返回的id与保存在session里的值是否一致，如果不一致则说明本次操作已经被提交过了

